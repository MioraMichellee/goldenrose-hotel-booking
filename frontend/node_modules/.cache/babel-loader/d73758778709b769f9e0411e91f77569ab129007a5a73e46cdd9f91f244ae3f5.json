{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport { useRef, useCallback } from 'react';\n/**\r\n * This hook creates an internal copy of a `ref`\r\n * and returns a new `ref`-alike setter function\r\n * that updates both `ref` and the internal copy of it.\r\n * That `ref`-alike setter function could then be passed\r\n * to child elements instead of the original `ref`.\r\n *\r\n * The internal copy of the `ref` can then be used to\r\n * call instance methods like `.focus()`, etc.\r\n *\r\n * One may ask: why create a copy of `ref` for \"internal\" use\r\n * when the code could use the original `ref` for that.\r\n * The answer is: the code would have to dance around the original `ref` anyway\r\n * to figure out whether it exists and to find out the internal implementation of it\r\n * in order to read its value correctly. This hook encapsulates all that \"boilerplate\" code.\r\n * The returned copy of the `ref` is guaranteed to exist and functions as a proper ref \"object\".\r\n * The returned `ref`-alike setter function must be used instead of the original `ref`\r\n * when passing it to child elements.\r\n *\r\n * @param  {(object|function)} [externalRef] — The original `ref` that may have any internal implementation and might not even exist.\r\n * @return {any[]} Returns an array of two elements: a copy of the `ref` for \"internal\" use and a `ref`-alike setter function that should be used in-place of the original `ref` when passing it to child elements.\r\n */\n\nexport default function useExternalRef(externalRef) {\n  // Create a copy of the original `ref` (which might not exist).\n  // Both refs will point to the same value.\n  var refCopy = useRef(); // Updates both `ref`s with the same `value`.\n\n  var refSetter = useCallback(function (value) {\n    setRefsValue([externalRef, refCopy], value);\n  }, [externalRef, refCopy]);\n  return [refCopy, refSetter];\n} // Sets the same `value` of all `ref`s.\n// Some of the `ref`s may not exist in which case they'll be skipped.\n\nexport function setRefsValue(refs, value) {\n  for (var _iterator = _createForOfIteratorHelperLoose(refs), _step; !(_step = _iterator()).done;) {\n    var ref = _step.value;\n    if (ref) {\n      setRefValue(ref, value);\n    }\n  }\n} // Sets the value of a `ref`.\n// Before React Hooks were introduced, `ref`s used to be functions.\n// After React Hooks were introduces, `ref`s became objects with `.current` property.\n// This function sets a `ref`'s value regardless of its internal implementation,\n// so it supports both types of `ref`s.\n\nfunction setRefValue(ref, value) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else {\n    ref.current = value;\n  }\n}","map":{"version":3,"names":["useRef","useCallback","useExternalRef","externalRef","refCopy","refSetter","value","setRefsValue","refs","_iterator","_createForOfIteratorHelperLoose","_step","done","ref","setRefValue","current"],"sources":["/mnt/Disque_local1/Projet IHM/frontend/node_modules/react-phone-number-input/source/useExternalRef.js"],"sourcesContent":["import { useRef, useCallback } from 'react'\r\n\r\n/**\r\n * This hook creates an internal copy of a `ref`\r\n * and returns a new `ref`-alike setter function\r\n * that updates both `ref` and the internal copy of it.\r\n * That `ref`-alike setter function could then be passed\r\n * to child elements instead of the original `ref`.\r\n *\r\n * The internal copy of the `ref` can then be used to\r\n * call instance methods like `.focus()`, etc.\r\n *\r\n * One may ask: why create a copy of `ref` for \"internal\" use\r\n * when the code could use the original `ref` for that.\r\n * The answer is: the code would have to dance around the original `ref` anyway\r\n * to figure out whether it exists and to find out the internal implementation of it\r\n * in order to read its value correctly. This hook encapsulates all that \"boilerplate\" code.\r\n * The returned copy of the `ref` is guaranteed to exist and functions as a proper ref \"object\".\r\n * The returned `ref`-alike setter function must be used instead of the original `ref`\r\n * when passing it to child elements.\r\n *\r\n * @param  {(object|function)} [externalRef] — The original `ref` that may have any internal implementation and might not even exist.\r\n * @return {any[]} Returns an array of two elements: a copy of the `ref` for \"internal\" use and a `ref`-alike setter function that should be used in-place of the original `ref` when passing it to child elements.\r\n */\r\nexport default function useExternalRef(externalRef) {\r\n  // Create a copy of the original `ref` (which might not exist).\r\n  // Both refs will point to the same value.\r\n  const refCopy = useRef()\r\n\r\n  // Updates both `ref`s with the same `value`.\r\n  const refSetter = useCallback((value) => {\r\n    setRefsValue([externalRef, refCopy], value)\r\n  }, [\r\n    externalRef,\r\n    refCopy\r\n  ])\r\n\r\n  return [refCopy, refSetter]\r\n}\r\n\r\n// Sets the same `value` of all `ref`s.\r\n// Some of the `ref`s may not exist in which case they'll be skipped.\r\nexport function setRefsValue(refs, value) {\r\n  for (const ref of refs) {\r\n    if (ref) {\r\n      setRefValue(ref, value)\r\n    }\r\n  }\r\n}\r\n\r\n// Sets the value of a `ref`.\r\n// Before React Hooks were introduced, `ref`s used to be functions.\r\n// After React Hooks were introduces, `ref`s became objects with `.current` property.\r\n// This function sets a `ref`'s value regardless of its internal implementation,\r\n// so it supports both types of `ref`s.\r\nfunction setRefValue(ref, value) {\r\n  if (typeof ref === 'function') {\r\n    ref(value)\r\n  } else {\r\n    ref.current = value\r\n  }\r\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,MAAT,EAAiBC,WAAjB,QAAoC,OAApC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,cAATA,CAAwBC,WAAxB,EAAqC;EAClD;EACA;EACA,IAAMC,OAAO,GAAGJ,MAAM,EAAtB,CAHkD,CAKlD;;EACA,IAAMK,SAAS,GAAGJ,WAAW,CAAC,UAACK,KAAD,EAAW;IACvCC,YAAY,CAAC,CAACJ,WAAD,EAAcC,OAAd,CAAD,EAAyBE,KAAzB,CAAZ;EACD,CAF4B,EAE1B,CACDH,WADC,EAEDC,OAFC,CAF0B,CAA7B;EAOA,OAAO,CAACA,OAAD,EAAUC,SAAV,CAAP;AACD,C,CAED;AACA;;AACA,OAAO,SAASE,YAATA,CAAsBC,IAAtB,EAA4BF,KAA5B,EAAmC;EACxC,SAAAG,SAAA,GAAAC,+BAAA,CAAkBF,IAAlB,GAAAG,KAAA,IAAAA,KAAA,GAAAF,SAAA,IAAAG,IAAA,GAAwB;IAAA,IAAbC,GAAa,GAAAF,KAAA,CAAAL,KAAA;IACtB,IAAIO,GAAJ,EAAS;MACPC,WAAW,CAACD,GAAD,EAAMP,KAAN,CAAX;IACD;EACF;AACF,C,CAED;AACA;AACA;AACA;AACA;;AACA,SAASQ,WAATA,CAAqBD,GAArB,EAA0BP,KAA1B,EAAiC;EAC/B,IAAI,OAAOO,GAAP,KAAe,UAAnB,EAA+B;IAC7BA,GAAG,CAACP,KAAD,CAAH;EACD,CAFD,MAEO;IACLO,GAAG,CAACE,OAAJ,GAAcT,KAAd;EACD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}